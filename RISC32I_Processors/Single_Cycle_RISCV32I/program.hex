001000b7  # LUI x1, 0x1        ; x1=0x00010000
00200437  # AUIPC x8, 0x200    ; x8=0x00020000
003008b7  # LUI x17, 0x300    ; x17=0x00030000
00400c37  # AUIPC x24, 0x400  ; x24=0x00040004
00500193  # ADDI x3, x1, 5    ; x3=0x00010005
00600213  # ADDI x4, x0, 6    ; x4=6
00700393  # ADDI x7, x1, 7    ; x7=0x00010007
00800413  # ADDI x8, x0, 8    ; x8=8 (overwrites AUIPC, but ok for demo)
00900593  # ADDI x11, x1, 9   ; x11=0x00010009
001000b7  # LUI x1, 0x1        ; Reset x1 for variety
002001b7  # LUI x3, 0x200      ; x3=0x00020000
00300237  # AUIPC x4, 0x300    ; x4=0x00030008
004002b7  # LUI x5, 0x400      ; x5=0x00040000
00500337  # AUIPC x6, 0x500    ; x6=0x00050010
006003b7  # LUI x7, 0x600      ; x7=0x00060000
00700437  # AUIPC x8, 0x700    ; x8=0x00070018
008004b7  # LUI x9, 0x800      ; x9=0x00080000
00900537  # AUIPC x10, 0x900   ; x10=0x00090020
002081b3  # ADD x3, x1, x2     ; x3 = x1 + x2 (alu_op=0000)
40308233  # SUB x4, x1, x3     ; x4 = x1 - x3 (alu_op=0001, zero_flag=0)
001041b3  # AND x3, x0, x2     ; x3 = 0 & x2 = 0 (alu_op=0010, zero_flag=1)
002051b3  # OR x3, x1, x2      ; x3 = x1 | x2 (alu_op=0011)
003061b3  # XOR x12, x6, x3    ; x12 = x6 ^ x3 (alu_op=0100)
004071b3  # SLT x14, x7, x4    ; x14 = (x7 < x4)?1:0 signed (alu_op=1000)
005081b3  # SLTU x16, x8, x5   ; x16 = (x8 < x5)?1:0 unsigned (alu_op=1001)
006091b3  # SLL x17, x9, x6    ; x17 = x9 << x6[4:0] (alu_op=0101, shamt=x6%32)
0070a1b3  # SRL x20, x10, x7   ; x20 = x10 >> x7[4:0] (alu_op=0110)
4080a233  # SRA x4, x1, x3     ; x4 = x1 >>> x3[4:0] signed (alu_op=0111)
0020c1b3  # ADD x3, x1, x2     ; Repeat add for zero_flag=0
0030c233  # SUB x4, x1, x3     ; Repeat sub
0040d1b3  # AND x3, x1, x4     ; And non-zero
0050e1b3  # OR x28, x5, x6     ; Or
0060f1b3  # XOR x29, x6, x7    ; Xor
007102b3  # SLT x30, x7, x0    ; SLT with x0=0
008113b3  # SLTU x31, x8, x1   ; SLTU
009124b3  # SLL x9, x9, x2     ; SLL
00a135b3  # SRL x10, x10, x3   ; SRL
40b14633  # SRA x12, x11, x4   ; SRA
005147b3  # SLTI x10, x2, 5    ; x10 = (x2 < 5)?1:0 signed (I-type, alu_op=1000)
00615893  # SLTIU x17, x3, 6   ; x17 = (x3 < 6)?1:0 unsigned (alu_op=1001)
00716a13  # XORI x20, x4, 7    ; x20 = x4 ^ 7 (alu_op=0100)
00817b93  # ORI x23, x5, 8     ; x23 = x5 | 8 (alu_op=0011)
00918c93  # ANDI x25, x6, 9    ; x25 = x6 & 9 (alu_op=0010)
00a19d13  # ADDI x26, x7, 10   ; x26 = x7 + 10 (alu_op=0000)
00b1ae93  # SLLI x29, x8, 11   ; x29 = x8 << 11 (alu_op=0101)
00c1bf93  # SRLI x31, x9, 12   ; x31 = x9 >> 12 (alu_op=0110)
40d1c0b3  # SRAI x1, x10, 13   ; x1 = x10 >>> 13 (alu_op=0111)
00e1d193  # ADDI x3, x11, 14   ; More addi
00f1e213  # ADDI x4, x12, 15   ; x4=15 (for branch prep)
0101f393  # ADDI x7, x13, 16   ; x7=16
01120513  # ADDI x10, x0, 17   ; x10=17
01221693  # ADDI x13, x0, 18   ; x13=18
01322813  # ADDI x16, x0, 19   ; x16=19
01423993  # ADDI x19, x0, 20   ; x19=20
01524a13  # ADDI x20, x0, 21   ; x20=21
01625b93  # ADDI x23, x0, 22   ; x23=22
01726c53  # ADDI x24, x0, 23   ; x24=23 (negative prep: but addi positive)
01827d13  # ADDI x26, x0, -24  ; Wait, imm sign-ext: 0xffe0 (for <0)
01928e93  # ADDI x29, x0, -25  ; 0xffe0 approx
00402023  # SW x0, 0(x0)       ; Mem[0]=0 (mem_write=1, addr=0+0)
00502823  # SW x1, 4(x0)       ; Mem[4]=x1
006030a3  # SW x2, 8(x0)       ; Mem[8]=x2
00703923  # SW x3, 12(x0)      ; Mem[12]=x3
00804203  # SW x4, 16(x0)      ; Mem[16]=x4
00904aa3  # SW x5, 20(x0)      ; Mem[20]=x5
00a053e3  # SW x6, 24(x0)      ; Mem[24]=x6
00b05c63  # SW x7, 28(x0)      ; Mem[28]=x7
00c065a3  # SW x8, 32(x0)      ; Mem[32]=x8
00d06ee3  # SW x9, 36(x0)      ; Mem[36]=x9
00e07823  # SW x10, 40(x0)     ; Mem[40]=x10
00f081a3  # SW x11, 44(x0)     ; Mem[44]=x11
01008b03  # SW x12, 48(x0)     ; Mem[48]=x12
01109463  # SW x13, 52(x0)     ; Mem[52]=x13
01209de3  # SW x14, 56(x0)     ; Mem[56]=x14
0130a723  # SW x15, 60(x0)     ; Mem[60]=x15
0140b0a3  # SW x16, 64(x0)     ; Mem[64]=x16
0150b9e3  # SW x17, 68(x0)     ; Mem[68]=x17
0160c323  # SW x18, 72(x0)     ; Mem[72]=x18
0170cbe3  # SW x19, 76(x0)     ; Mem[76]=x19
0180d4a3  # SW x20, 80(x0)     ; Mem[80]=x20
0190dde3  # SW x21, 84(x0)     ; Mem[84]=x21
01a0e6e3  # SW x22, 88(x0)     ; Mem[88]=x22
01b0efa3  # SW x23, 92(x0)     ; Mem[92]=x23
01c0f823  # SW x24, 96(x0)     ; Mem[96]=x24
01d10163  # SW x25, 100(x0)    ; Mem[100]=x25
01e10aa3  # SW x26, 104(x0)    ; Mem[104]=x26
01f113e3  # SW x27, 108(x0)    ; Mem[108]=x27
02011c23  # SW x28, 112(x0)    ; Mem[112]=x28
021125a3  # SW x29, 116(x0)    ; Mem[116]=x29
02212ee3  # SW x30, 120(x0)    ; Mem[120]=x30
02313763  # SW x31, 124(x0)    ; Mem[124]=x31
00002303  # LW x6, 0(x0)       ; x6=Mem[0]=0 (mem_read=1, mem2reg=1)
00102b83  # LW x23, 4(x0)      ; x23=Mem[4]=x1 prev
00203403  # LW x8, 8(x0)       ; x8=Mem[8]
00303c83  # LW x25, 12(x0)     ; x25=Mem[12]
00404503  # LW x10, 16(x0)     ; x10=Mem[16]
00504d83  # LW x27, 20(x0)     ; x27=Mem[20]
00605603  # LW x12, 24(x0)     ; x12=Mem[24]
00705e83  # LW x29, 28(x0)     ; x29=Mem[28]
00806703  # LW x14, 32(x0)     ; x14=Mem[32]
00906f83  # LW x31, 36(x0)     ; x31=Mem[36]
00a07803  # LW x16, 40(x0)     ; x16=Mem[40]
00b08083  # LW x1, 44(x0)      ; x1=Mem[44]
00c08a003 # LW x18, 48(x0)     ; x18=Mem[48]
00d093803 # LW x7, 52(x0)      ; x7=Mem[52]
00e09c003 # LW x24, 56(x0)     ; x24=Mem[56]
00f0a4803 # LW x9, 60(x0)      ; x9=Mem[60]
0100ad803 # LW x27, 64(x0)     ; x27=Mem[64] (overwrite for variety)
0110b7003 # LW x14, 68(x0)     ; x14=Mem[68]
0120c0803 # LW x1, 72(x0)      ; x1=Mem[72]
0130c9803 # LW x19, 76(x0)     ; x19=Mem[76]
0140d2803 # LW x5, 80(x0)      ; x5=Mem[80]
0150db803 # LW x23, 84(x0)     ; x23=Mem[84]
0160e4803 # LW x9, 88(x0)      ; x9=Mem[88]
0170ed803 # LW x27, 92(x0)     ; x27=Mem[92]
0180f6803 # LW x13, 96(x0)     ; x13=Mem[96]
019100003 # LW x0, 100(x0)     ; x0=Mem[100] (no write, but rd=0)
01a109803 # LW x19, 104(x0)    ; x19=Mem[104]
01b112c03 # LW x4, 108(x0)     ; x4=Mem[108]
01c11b403 # LW x22, 112(x0)    ; x22=Mem[112]
01d124803 # LW x9, 116(x0)     ; x9=Mem[116]
01e12dc03 # LW x7, 120(x0)     ; x7=Mem[120]
01f136003 # LW x12, 124(x0)    ; x12=Mem[124]
00208163  # BEQ x1, x0, 8      ; Not taken (x1!=0, func3=000, zero=0, pc_src=0)
00308a63  # BEQ x2, x3, 16     ; Taken if x2==x3 (setup earlier equal, imm=16, pc_src=1 forward)
004093e3  # BNE x1, x0, 24     ; Taken (x1!=0, func3=001, ~zero=1, imm=24 forward)
00509c63  # BNE x2, x3, 32     ; Not taken (equal, ~zero=0)
0060a5e3  # BLT x1, x0, 40     ; Not taken (x1=pos >0, func3=100, signed < false)
0070ae23  # BLT x26, x0, 48    ; Taken (x26=-24 <0 signed, imm=48 forward)
0080b7a3  # BGE x1, x0, 56     ; Taken (x1>=0, func3=101)
0090c023  # BGE x26, x0, 64    ; Not taken (x26<0)
00a0c9a3  # BLTU x1, x0, 72    ; Not taken (x1>0 unsigned)
00b0d223  # BLTU x26, x0, 80   ; Taken? Wait x26=0xffe0 (large unsigned >0? No: imm negative but addr calc; adjust: use pos small)
00c0dae3  # BGEU x1, x0, 88    ; Taken (x1>=0 unsigned)
00d0e363  # BGEU x26, x0, 96   ; Taken (0xffe0 >0 unsigned)
00e0ebe3  # BEQ x0, x0, -104   ; Taken backward loop (zero=1, imm=-104, pc_src=1 back to reuse stores/loads)
00f0f463  # BNE x0, x1, 104    ; Not taken (x0==0, but BNE ~zero=0? Wait x0==x1? No x1!=0, ~zero=1 taken forward skip jumps)
010105e3  # BLT x0, x1, 112    ; Taken (0 < x1 signed)
01110e23  # BGE x0, x1, 120    ; Not taken (0 < x1)
012117a3  # BLTU x0, x1, 128   ; Taken (0 < x1 unsigned)
01312023  # BGEU x0, x1, 136   ; Not taken
014128a3  # BEQ x1, x2, 144    ; Not taken (unequal)
01513123  # BNE x1, x2, 152    ; Taken
016139a3  # BLT x2, x1, 160    ; Taken if x2<x1
01714223  # BGE x2, x1, 168    ; Not taken
01814aa3  # BLTU x2, x1, 176   ; Taken
01915323  # BGEU x2, x1, 184   ; Not taken
020005ef  # JAL x11, 28        ; Jump forward 28 bytes (imm=28/2=14 instr? Wait hex for J imm=28), link x11=PC+4
02100e6f  # JAL x29, 56        ; Jump forward, link x29
022017ef  # JAL x31, 84        ; Jump forward, link x31
0230206f  # JAL x0, 112        ; Jump no link (rd=0)
024028ef  # JAL x12, 140       ; Jump forward
0250316f  # JAL x13, 168       ; Jump
02603a6f  # JAL x14, 196       ; Jump to end-ish
027043ef  # JAL x15, 224       ; Large forward (wrap? but %256 ok)
02804c6f  # JAL x16, 252       ; Near end
029055ef  # JAL x17, 280       ; Beyond, but mod 256
02a05e6f  # JAL x18, 308       ; Variety
02b067ef  # JAL x19, 336       ; 
02c0706f  # JAL x0, 364        ; No link
02d079ef  # JAL x21, 392       ; 
02e0826f  # JAL x22, 420       ; End section
0000006f  # JALR x0, 0(x0)     ; Jump to 0+0=0 (loop back to start, rd=0 no write)
00100067  # JALR x0, 0(x1)     ; Jump to x1+0 (e.g., 0x10000, but %256=0, variety)
002001ef  # JALR x1, 0(x0)     ; Link x1=PC+4, jump to 0
0030026f  # JALR x2, 4(x0)     ; Jump to 0+4=4
004003ef  # JALR x3, 8(x0)     ; Jump to 8
00500467  # JALR x4, 12(x1)    ; Jump to x1+12
006005ef  # JALR x5, 16(x0)    ; 
0070066f  # JALR x6, 20(x0)    ; 
008007ef  # JALR x7, 24(x0)    ; 
00900867  # JALR x8, 28(x0)    ; 
00a009ef  # JALR x9, 32(x0)    ; End with loops
